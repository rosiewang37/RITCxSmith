import requests
import time
import threading
import ctypes
import winsound
from config import *

# Session Setup
s = requests.Session()
s.headers.update({"X-API-key": API_KEY})

# --- API WRAPPERS ---
def get_tick_status():
    try:
        r = s.get(f"{API_URL}/case")
        return (r.json()["tick"], r.json()["status"]) if r.ok else (0, "STOPPED")
    except: return 0, "STOPPED"

def get_positions():
    try:
        r = s.get(f"{API_URL}/securities")
        if r.ok:
            out = {p["ticker"]: int(p.get("position", 0)) for p in r.json()}
            for k in [BULL, BEAR, RITC, USD, CAD]: out.setdefault(k, 0)
            return out
    except: pass
    return {}

def best_bid_ask(ticker):
    # Returns best bid and ask prices for a ticker
    r = s.get(f"{API_URL}/securities/book", params={"ticker": ticker})
    r.raise_for_status()
    book = r.json()
    'Why choose [0] here, not [1]? Is the price for bids and asks also generated by r'
    bid = float(book["bids"][0]["price"]) if book["bids"] else 0.0
    ask = float(book["asks"][0]["price"]) if book["asks"] else 1e12
    return bid, ask

def place_mkt(ticker, action, qty): # type: LMT?
    # Sends Market orders; price param is ignored by most RIT cases when type=MARKET
    return s.post(f"{API_URL}/orders",
                  params={"ticker": ticker, "type": "MARKET",
                          "quantity": int(qty), "action": action}).ok

# --- RISK MANAGEMENT ---
def within_limits(ticker, action, qty, price=0):
    pos = get_positions()
    if not pos: return False
    
    sign = 1 if action == "BUY" else -1
    
    # Current State
    curr_gross_stock = abs(pos[BULL]) + abs(pos[BEAR]) + abs(pos[RITC] * 2)
    curr_usd = pos[USD]

    # Projected Impact
    proj_gross_stock = curr_gross_stock
    if ticker in [BULL, BEAR, RITC]:
        mult = 2 if ticker == RITC else 1
        proj_gross_stock += (qty * mult)

    usd_impact = sign * qty if ticker == USD else -(sign * qty * price) if ticker == RITC else 0
    proj_usd = curr_usd + usd_impact

    # Logic: Allow trade if under limit OR if it reduces risk (Unwinding)
    stock_ok = (proj_gross_stock < MAX_STOCK_GROSS) or (proj_gross_stock < curr_gross_stock)
    cash_ok  = (abs(proj_usd) < MAX_CASH_GROSS) or (abs(proj_usd) < abs(curr_usd))

    return stock_ok and cash_ok

def force_hedge(ticker, action, qty):
    """ Retries critical hedges to ensure Net 0 """
    for i in range(5):
        if post_order(ticker, action, qty): return True
        time.sleep(0.05)
    print(f"FATAL: FAILED TO HEDGE {ticker} {action} {qty}")
    return False

# --- ALERTS ---
def _popup_thread(title, msg):
    try: ctypes.windll.user32.MessageBoxTimeoutW(0, msg, title, 0x40 | 0x1000, 0, 3000)
    except: pass

def trigger_alert(action, qty):
    try:
        winsound.Beep(1000, 200); winsound.Beep(1200, 200)
        t = threading.Thread(target=_popup_thread, args=(f"{action} {qty:,}", f"GO TO ASSETS TAB!\nAction: {action}\nQty: {qty:,}"))
        t.daemon = True; t.start()
    except: pass

def check_converters():
    pos = get_positions()
    ritc = pos.get(RITC, 0)
    blocks = int(abs(ritc) // CONVERTER_BLOCK)
    if blocks > 0:
        action = "ETF-REDEMPTION" if ritc > 0 else "ETF-CREATION"
        trigger_alert(action, blocks * CONVERTER_BLOCK)